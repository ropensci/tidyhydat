---
title: "Two examples of using tidyhydat"
author: "Sam Albers"
date: "`r Sys.Date()`"
output:
  html_vignette:
     keep_md: true
vignette: >
  %\VignetteIndexEntry{tidyhydat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width=7, fig.height=7)
```

# Introduction

The real power of `tidyhydat` comes with its ability to efficiently import data into R which then can be used in conjunction with R's vast array of packages. `tidyhydat` gets hydrometric data into R and allows the user to start conducting data analysis immediately. This vignette is designed to take a user through two short examples of hydrological visualization and analysis and will therefore use additional tools beyond simply the functions in `tidyhydat`. 

## Familiarity with the tidyverse
`tidyhydat` is designed to exist as a "tidy tools" that is complementary to the `tidyverse` suite of packages. This vignette assumes some familiarity with basic tidy tools particularly `dplyr`, `tidyr`, `ggplot2`, `lubridate` and `purrr`. The [R for Data Science](http://r4ds.had.co.nz/) book by Garrett Grolemund and Hadley Wickham is an enormously useful book both for general R use and for `tidyhydat`. The following is a list of useful links to begin learning particular aspect of each `tidyverse` package:

 - `dplyr`: http://dplyr.tidyverse.org/
 - `tidyr`: http://tidyr.tidyverse.org/
 - `ggplot2`: http://ggplot2.tidyverse.org/
 - `purrr`: http://purrr.tidyverse.org/
 - `lubridate`: http://lubridate.tidyverse.org/

# Basic Data Extraction and Plotting

## Objective
Use `tidyhydat` to find the longest hydrometric network in Canada then use `ggplot2` to create a visualization of the discharge data. 

In this section, we will be using `dplyr`, a data manipulation package, `ggplot2`, an extremely simple yet powerful data visualization tool, `lubridate` a package that aids significant in working with date and times in R and of course `tidyhydat`. Take a deep breathe. Though this might seem like an overwhelming onslaught of information on packages, each of these packages will save you considerable time with relatively minimal learning investment.
```{r pkg_load_1}
library(tidyhydat)
library(dplyr)
library(ggplot2)
library(lubridate)
```

Your first step is to download the HYDAT database which `tidyhydat` facilitate for you:
```{r dl_hy, eval=FALSE}
download_hydat()
```
This should be the only instance where you will need to interact directly with HYDAT. Each `tidyhydat` function prefixed with `hy` will automatically know where to look for HYDAT saving you the trouble. When using `tidyhydat`, often your first task is to find the station(s) that you are interested in. Because we are interested in the longest record we can extract that information with `hy_stn_data_range()` and then feed that information to `hy_daily_flows()` like this: 

```{r, eval= FALSE, warning=FALSE, message=FALSE}
longest_record_data <- hy_stn_data_range() %>%
  filter(RECORD_LENGTH == max(RECORD_LENGTH)) %>%
  pull(STATION_NUMBER) %>%
  hy_daily_flows()
```
Let's break this down line by line to understand how `tidyhydat` uses tidy tools. First we are interested in getting data on record length:
```{r data_range}
hy_stn_data_range()
```
Our objective here is to filter from this data for the station that has the longest record. You'll also notice this symbol `%>%` which in R is called a pipe. In code, read it as the word *then*. So for the data_range data we want to grab the data *then* filter it by the longest value of `RECORD_LENGTH`:
```{r filter}
hy_stn_data_range() %>%
  filter(RECORD_LENGTH == max(RECORD_LENGTH))
```
*then* pull the `STATION_NUMBER` that has the longest record:
```{r pull}
hy_stn_data_range() %>%
  filter(RECORD_LENGTH == max(RECORD_LENGTH)) %>%
  pull(STATION_NUMBER)
```
*then* feed that number to `hy_daily_flows()`
```{r, full1}
longest_record_data <- hy_stn_data_range() %>%
  filter(RECORD_LENGTH == max(RECORD_LENGTH)) %>%
  pull(STATION_NUMBER) %>%
  hy_daily_flows()
```

The result of this collection of simple functions is that we've extract data from station `02HA003`.If we wanted more information on this station we could query other tables in HYDAT for more information. The `hy_stations()` function is very useful and outputs considerable metadata on a given station:
```{r hy_stns}
hy_stations(station_number = unique(longest_record_data$STATION_NUMBER)) %>%
  as.list()
```


We know know that this station is actually *NIAGARA RIVER AT QUEENSTON*. As a first step toward visualization, let's simply plot the time series for the entire record with a smoother added:
```{r old_rec}
longest_record_data %>%
  ggplot(aes(x = Date, y = Value)) +
  geom_line() +
  geom_point() +
  geom_smooth() +
  labs(y = "Discharge (m)") +
  theme_minimal()
```
You can see very clearly where continuous monitoring was established. However, this type of plot obscures much of the data that we are interested in. We could plot all the years on the same axis and separate year by line colour. That requires a little bit of manipulation ahead of plotting using both `dplyr` and `lubridate`. Remember you can run a pipe adding one line at a time and comparing the outputs to get a sense of what each step is doing:
```{r old_rec_yr}
longest_record_data %>%
  mutate(dayofyear = yday(Date), Year = year(Date)) %>%
  mutate(dayofyear_formatted = as.Date(dayofyear - 1, origin = "2016-01-01")) %>% ## leap year as placeholder
  ggplot(aes(x = dayofyear_formatted, y = Value, colour = Year)) +
  geom_line() +
  geom_point() +
  scale_x_date(date_labels = "%b %d") +
  labs(y = "Discharge (m)") +
  theme_minimal()
```

This still isn't a very useful plot mostly because we are mis-using colour. Consider for example if rather than a line plot we use a tile plot and modified our colour scale to include more colours:
```{r tile_plt}
longest_record_data %>%
  mutate(dayofyear = yday(Date), Year = year(Date)) %>%
  mutate(dayofyear_formatted = as.Date(dayofyear - 1, origin = "2016-01-01")) %>% ## leap year as placeholder
  ggplot(aes(x = dayofyear_formatted, y = Year, fill = Value)) +
  geom_tile() +
  scale_x_date(date_labels = "%b %d") +
  scale_fill_gradientn(name = "Discharge (m^3/s)", colours = rainbow(10)) +
  labs(y = "Year", x = "Date") +
  theme_minimal() +
  theme(legend.position="bottom")
```
This type of plot provides a clear indicator of discharge patterns over time. Our analysis ends here but once can imagine drawing in climate indices and variation to help explain periods of extreme discharge. 

# Percentiles calculation
For our second example, we will illustrate how to calculate a common metric used in hydrology: percentiles. For this approach we will use another piped series of functions to zero in on the station that we want. The packages we need for this example are loaded first:
```{r pkg_load_2}
library(tidyhydat)
library(dplyr)
library(ggplot2)
library(lubridate)
```
The pipe below finds the station that has realtime data in the [Reference Hydrometric Basin Network](https://www.canada.ca/en/environment-climate-change/services/water-overview/quantity/monitoring/survey/hydrometric-program-national-partnership/network.html) (RHBN) in the territory of Nunavut that has the longest record then grabs all the daily flow information:

```{r}
nunavut_stn_flows <- hy_stations() %>%
  filter(HYD_STATUS == "ACTIVE") %>%
  filter(REAL_TIME == TRUE) %>%
  filter(RHBN == TRUE) %>%
  filter(PROV_TERR_STATE_LOC == "NU") %>%
  pull(STATION_NUMBER) %>%
  hy_stn_data_range() %>%
  filter(RECORD_LENGTH == max(RECORD_LENGTH)) %>%
  pull(STATION_NUMBER) %>%
  hy_daily_flows()
``` 
Armed with our data, we can now evaluate the historical distribution of data then compare it to some real time data. First we need to calculate where an individual observation is distributed against all other distributions on that day. The `prctile` column tells us what percentage of values on that same day over the entire data record fall above and below the observations on that row. We are restricting our analysis to the last thirty days from when this vignette was compiled. The `ecdf()` function creates an equation to calculate percentiles based on the `Value` column (i.e discharge) then takes each individual observation of `Value` and calculates the percentile. 
```{r}
pct_flow <- nunavut_stn_flows %>%
  mutate(dayofyear = yday(Date), Year = year(Date)) %>%
  filter(dayofyear %in% yday(seq.Date(from = (Sys.Date()-30), 
                                     to = Sys.Date(), by = "day"))) %>%
  group_by(dayofyear) %>%
  mutate(prctile = ecdf(Value)(Value)) %>%
  mutate(Date_no_year = dmy(paste0(day(Date),"-",month(Date),"-",year(Sys.Date()))))
```

To collect real time data, we can use the `realtime_dd()` function in tidyhydat. Because real time data is collected in hourly (or higher) intervals and we are operating on a daily basis, we first need to take a daily mean of discharge. Again this is accomplished in a pipe:
```{r realtime}
nunavut_realtime <- realtime_dd(unique(nunavut_stn_flows$STATION_NUMBER)) %>%
  mutate(Date_day = as.Date(Date)) %>%
  group_by(Date_day) %>%
  summarise(Value = mean(Value, na.rm = TRUE))
```

Finally we can plot all of this on to one figure. This type of plot is useful to combine historical data sources with real time data and provide a visual assessment of how typical flows in a given system are. 

CAUTION: All real time data are presented AS IS and represent unapproved data.
```{r, pcrtile_plt}
ggplot(pct_flow, aes(x = Date_no_year, y = Value)) +
  geom_point(aes(colour = prctile)) +
  geom_line(data = nunavut_realtime, aes(x = Date_day), colour = "black") +
  geom_point(data = nunavut_realtime, aes(x = Date_day, shape = factor(year(Date_day))), colour = "black") +
  scale_colour_gradientn(name = "Discharge Percentile", colours = rainbow(10)) +
  scale_shape_discrete(name = "Year") +
  theme_minimal() +
  labs(title = "Historical flow relative to current year",
       subtitle = "Current year flows are displayed in black",
       caption = "Real time data is presents AS IS and represents unapproved data",
       x = "Date", y = "Discharge (m^3/s)")
```

